package main

import (
	// "fmt";
	
)

// func main(){
	
// 	grades := [3]int{97, 92, 93}
// 	fmt.Printf("Grades %v, %T \n", grades, grades)

// 	grades2 := [...]int{1,2,3,4,5,6} 
// 	fmt.Println("\ngrades2: ", grades2)

// 	var students [3] string
// 	fmt.Println("\nstudents: ", students)
// 	students[0] = "Lisa"
// 	fmt.Println("\nstudents: ", students)
// 	students[2] = "Visa"
// 	fmt.Println("\nstudents: ", students)
// 	students[1] = "Bisa"
// 	fmt.Println("\nstudents: ", students)
// 	fmt.Println("\nstudent1: ", students[0])
// 	fmt.Println("\nNumber of students: ", len(students))

// 	var identityMatrix = [3][3]int{
// 		[3]int {1,0,0},
// 		[3]int {0,1,0},
// 		[3]int {0,0,1},
// 	}

// 	fmt.Println("\nIdentity matrix: ", identityMatrix)

// 	fmt.Println("\nb is created from a copy of a, and they do not point to the same address")

// 	a := [...]int{1,2,3}
// 	b := a

// 	b[0] = 10
// 	b[2] = 50
// 	fmt.Printf("\nArray a is %v and array b is %v", a, b)

// 	fmt.Println("\n\nSlice c points to d and is not a copy of d")

// 	d := [...]int{51, 43, 124}
// 	c := &d // address of d

// 	fmt.Println(d, c)

// 	// The problem with an array is that it cannot be exteded after it's side is defined

// 	e := []int{1,2,3} // A slice
// 	f := e // A slice is always memory referenced

// 	f[0] = 21

// 	fmt.Printf("\nSlice e: %v", e)

// 	fmt.Printf("\n\nLike in python, we can use the array indices to access parts of a slice. Slicing operations can also be done on arrays")

// 	g := []int{1,2,3,4,5,6,7,8,9,10}

// 	fmt.Printf("\n\nFirst 3 elements of the slice g: %v", g[:3])
// 	fmt.Printf("\nLast 3 elements of the slice g: %v", g[7:])
// 	fmt.Printf("\nEntire slice g: %v", g[:])

// }

